ì €ëŠ” í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ë¥¼ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤. ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ì‹ ê²½ ì“´ ë¶€ë¶„ì´ ë°”ë¡œ ë©”ì¸ í˜ì´ì§€ì¸ë°ìš”. ì•„ë¬´ë˜ë„ ì²˜ìŒ ì´ë¯¸ì§€ë¥¼ ì „ë‹¬í•´ì£¼ëŠ” ë©”ì¸ì´ê¸° ë•Œë¬¸ì— ì´ê²ƒì €ê²ƒ ë§ì´ ì‹œë„ë¥¼ í•´ë³¸ ê²ƒ ê°™ì•„ìš”. ğŸ¤£ğŸ¤£

ì²«ì¸ìƒì´ ì¤‘ìš”í•œ ë§Œí¼ ë‹¨ìˆœí•œ ì •ì ì¸ í˜ì´ì§€ê°€ ì•„ë‹ˆë¼ í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì• ë‹ˆë©”ì´ì…˜ê³¼ ì¸í„°ë™ì…˜ì„ í™œìš©í•´ì„œ ë™ì ì¸ í™”ë©´ì„ ë§Œë“¤ê³ ì í–ˆìŠµë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ” ë©”ì¸ í˜ì´ì§€ë¥¼ êµ¬ì„±í•˜ëŠ” ì£¼ìš” ì½”ë“œë“¤ê³¼ ì—­í• ì„ í•˜ë‚˜ì”© ë¶„ì„í•˜ë©´ì„œ ê° ì»´í¬ë„ŒíŠ¸ê°€ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ ì•Œì•„ë³´ë ¤ê³  í•©ë‹ˆë‹¤!

***

ğŸ“Œ ê¸€ì˜ íë¦„ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤!

* 1ï¸âƒ£ `MainSection.tsx`: ë©”ì¸ í˜ì´ì§€ì˜ í•µì‹¬ êµ¬ì¡°
* 2ï¸âƒ£ `useMouseEffect.ts`: ë§ˆìš°ìŠ¤ ì›€ì§ì„ì— ë°˜ì‘í•˜ëŠ” íš¨ê³¼
* 3ï¸âƒ£ `useDashAnimation.ts`: SVG ì„ ì´ ê·¸ë ¤ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜
* 4ï¸âƒ£ `useTypewriterEffect.ts`: íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜
* 5ï¸âƒ£ `useYPositions.ts`: ìš”ì†Œë“¤ì˜ Y ìœ„ì¹˜ë¥¼ ë™ì ìœ¼ë¡œ ê³„ì‚°í•˜ì—¬ ë°°ì¹˜
* 6ï¸âƒ£ `Grid.tsx`: ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ
* 7ï¸âƒ£ `BigCompass.tsx & SmallCompass.tsx`: ì›€ì§ì´ëŠ” ë‚˜ì¹¨ë°˜ íš¨ê³¼
* 8ï¸âƒ£ `Wave.tsx`: ë¶€ë“œëŸ¬ìš´ ì›¨ì´ë¸Œ ì• ë‹ˆë©”ì´ì…˜

***

## 1ï¸âƒ£ ë©”ì¸ í˜ì´ì§€ì˜ í•µì‹¬ êµ¬ì¡°

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

`MainSection.tsx`ëŠ” ë©”ì¸ í˜ì´ì§€ ì „ì²´ë¥¼ êµ¬ì„±í•˜ëŠ” í•µì‹¬ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
ì¦‰, ì‚¬ì´íŠ¸ì— ë“¤ì–´ì™”ì„ ë•Œ ê°€ì¥ ì²˜ìŒ ë³´ì´ëŠ” í™”ë©´ì„ ë‹´ë‹¹í•˜ê³  ìˆìŠµë‹ˆë‹¤.

* ë§ˆìš°ìŠ¤ ì›€ì§ì„ì— ë”°ë¼ ë°°ê²½ ìš”ì†Œê°€ ë°˜ì‘í•˜ëŠ” íš¨ê³¼
* ìŠ¤í¬ë¡¤í•  ë•Œ ì• ë‹ˆë©”ì´ì…˜ì´ ì‹¤í–‰ë˜ëŠ” íš¨ê³¼
* íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜ê³¼ ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ ë°°ì¹˜

```tsx
// import ë¶€ë¶„ ìƒëµ...

export default function MainSection() {
	const { gMatrix, circleMatrix, rotation, handleMouseMove } = useMouseEffect();
	const scrollStartRef = useRef<HTMLDivElement | null>(null);

	// ì—¬ëŸ¬ ìš”ì†Œë“¤ì˜ Ref
	const gridListRefs = useRef<(HTMLDivElement | null)[]>([]);
	const wordRefs = useRef<(SVGSVGElement | null)[]>([]);
	const typewriterRefs = useRef<(HTMLDivElement | null)>(null);

	useEffect(() => {
		gsap.registerPlugin(ScrollTrigger);
		const ctx = gsap.context(() => {
			const mainScroll = gsap.timeline({
				scrollTrigger: {
					trigger: scrollStartRef.current,
					start: "top top",
					end: "bottom+=10000 top",
					scrub: 3,
					pin: true,
					markers: true,
				},
			});

			// ë‹¤ì–‘í•œ gsap ì• ë‹ˆë©”ì´ì…˜ë“¤...
		});

		return () => ctx.revert();
	}, []);

	return (
		<div className="main_section" onMouseMove={handleMouseMove} ref={scrollStartRef}>
			<div className="big_compass">
				<BigCompass gMatrix={gMatrix} circleMatrix={circleMatrix}/>
			</div>
			<div className="small_compass">
				<SmallCompass rotation={rotation}/>
				<SmallCompass rotation={rotation}/>
			</div>
			<div className="wave_wrap">
				<Wave/>
			</div>
			<div className="grid_wrap">
				<Grid gridColumns={[{ gap: '10rem', paddingTop: '15rem', listConfig: [4, 2], gridListRefs }]}/>
			</div>
			<div className="word_wrap">
				<WordText wordRefs={wordRefs}/>
			</div>
			<div className="typewriter_wrap">
				<Typewriter typewriterRefs={typewriterRefs}/>
			</div>
			<Noise/>
		</div>
	)
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

ê¸¸ì´ëŠ” ê¸¸ì§€ë§Œ ë”±íˆ í¬ê²Œ ì„¤ëª…í•  ë¶€ë¶„ì€ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤.

GSAPì„ ì´ìš©í•œ ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í–ˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. mainScroll ìƒìˆ˜ë¥¼ timelineìœ¼ë¡œ ì„ ì–¸í•˜ê³  ë©”ì¸ì˜ ìµœìƒë‹¨ ìš”ì†Œì¸ `main_section`ì˜ `className`ì— GSAP `trigger`ë¥¼ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤.

`scrub`ê³¼ `pin`ì„ ì´ìš©í•˜ì—¬ ê³ ì •ëœ í™”ë©´ì—ì„œ ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì´ ì§„í–‰ë˜ë„ë¡ ê¸°ë³¸ì ì¸ ì„¤ì •ì„ í•˜ì˜€ìŠµë‹ˆë‹¤.

`scrub`: 3 â†’ ì• ë‹ˆë©”ì´ì…˜ì´ ìŠ¤í¬ë¡¤ ì†ë„ì— ë§ì¶° ë¶€ë“œëŸ½ê²Œ ì§„í–‰ë¨
`pin`: true â†’ ì• ë‹ˆë©”ì´ì…˜ ë„ì¤‘ í™”ë©´ì„ ê³ ì •ì‹œí‚´

***

## 2ï¸âƒ£ ë§ˆìš°ìŠ¤ ì›€ì§ì„ì— ë°˜ì‘í•˜ëŠ” íš¨ê³¼ (useMouseEffect.ts)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

`useMouseEffect.ts`ëŠ” ì‚¬ìš©ìì˜ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ê°ì§€í•˜ëŠ” í›…ìœ¼ë¡œ íŠ¹ì • SVG ìš”ì†Œì˜ ë³€í˜•(transform)ì„ ì¡°ì‘í•´ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ íšŒì „í•˜ê±°ë‚˜ ì´ë™í•˜ëŠ” íš¨ê³¼ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

* `BigCompass.tsx` â†’ í° ë‚˜ì¹¨ë°˜ì˜ íšŒì „ ë° ì´ë™ ì œì–´
* `SmallCompass.tsx` â†’ ì‘ì€ ë‚˜ì¹¨ë°˜ íšŒì „ íš¨ê³¼

ìš°ì„  ì•„ë˜ëŠ” ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
import { useRef, useState, useEffect } from "react";

const useMouseEffect = () => {
  const gMatrixRef = useRef({ a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 });
  const circleMatrixRef = useRef({ a: 0, b: 1, c: -1, d: 0, e: 1440, f: 0 });
  const rotationRef = useRef(0);

  const [gMatrix, setGMatrix] = useState(gMatrixRef.current);
  const [circleMatrix, setCircleMatrix] = useState(circleMatrixRef.current);
  const [rotation, setRotation] = useState(rotationRef.current);

  useEffect(() => {
    let animationFrameId: number;
    const updateMouseEffect = () => {
      setGMatrix({ ...gMatrixRef.current });
      setCircleMatrix({ ...circleMatrixRef.current });
      setRotation(rotationRef.current);
      animationFrameId = requestAnimationFrame(updateMouseEffect);
    };

    updateMouseEffect();
    return () => cancelAnimationFrame(animationFrameId);
  }, []);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const deltaX = (mouseX - centerX) / centerX;
    const deltaY = (mouseY - centerY) / centerY;

    gMatrixRef.current = {
      a: 1,
      b: deltaY * 0.01675,
      c: deltaX * -0.01675,
      d: 1,
      e: deltaX * 11,
      f: deltaY * -8,
    };

    rotationRef.current = deltaX * 10;
  };

  return { gMatrix, circleMatrix, rotation, handleMouseMove };
};
export default useMouseEffect;
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

#### 1. useRefë¡œ í–‰ë ¬(matrix)ê³¼ íšŒì „ê°’ì„ ê´€ë¦¬

```tsx
const gMatrixRef = useRef({ a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 });
const circleMatrixRef = useRef({ a: 0, b: 1, c: -1, d: 0, e: 1440, f: 0 });
const rotationRef = useRef(0);
```
* `gMatrixRef` â†’ g íƒœê·¸ì— ì ìš©í•  ë³€í˜• í–‰ë ¬(2D Transform) ì •ë³´ë¥¼ ì €ì¥
* `circleMatrixRef` â†’ circle íƒœê·¸ì˜ íšŒì „ í–‰ë ¬ ì •ë³´ë¥¼ ì €ì¥
* `rotationRef` â†’ ë‚˜ì¹¨ë°˜ì˜ íšŒì „ ê°’ì„ ê´€ë¦¬

ğŸ’¡ **í–‰ë ¬ì´ë€?**

* SVGì—ì„œ transform="matrix(a, b, c, d, e, f)" í˜•ì‹ìœ¼ë¡œ ë³€í˜•ì„ ì ìš©í•  ìˆ˜ ìˆìŒ.
* a, b, c, d â†’ ìŠ¤ì¼€ì¼ ë° ê¸°ìš¸ê¸° ì¡°ì •
* e, f â†’ X, Y ì¢Œí‘œ ì´ë™

<br/>

#### 2. useRefë¡œ í–‰ë ¬(matrix)ê³¼ íšŒì „ê°’ì„ ê´€ë¦¬

```tsx
const [gMatrix, setGMatrix] = useState(gMatrixRef.current);
const [circleMatrix, setCircleMatrix] = useState(circleMatrixRef.current);
const [rotation, setRotation] = useState(rotationRef.current);
```

* useStateë¥¼ ì‚¬ìš©í•´ì„œ ë¦¬ë Œë”ë§ë  ê°’ì„ ê´€ë¦¬
* ë§ˆìš°ìŠ¤ê°€ ì›€ì§ì¼ ë•Œë§ˆë‹¤ í–‰ë ¬ê°’ì´ ë³€ê²½ë˜ë©´, UIì— ë°˜ì˜ë¨

<br/>

#### 3. useEffectë¡œ ì§€ì†ì ì¸ ì—…ë°ì´íŠ¸ ì‹¤í–‰

```tsx
useEffect(() => {
  let animationFrameId: number;
  const updateMouseEffect = () => {
    setGMatrix({ ...gMatrixRef.current });
    setCircleMatrix({ ...circleMatrixRef.current });
    setRotation(rotationRef.current);
    animationFrameId = requestAnimationFrame(updateMouseEffect);
  };

  updateMouseEffect();
  return () => cancelAnimationFrame(animationFrameId);
}, []);
```

* `requestAnimationFrame`ì„ ì´ìš©í•´ ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ë¥¼ ì œê³µ
* ê³„ì†í•´ì„œ í˜„ì¬ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
* ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë  ë•Œ `cancelAnimationFrame()`ìœ¼ë¡œ ì •ë¦¬

ğŸ’¡ **ì™œ `requestAnimationFrame`ì„ ì‚¬ìš©í–ˆì„ê¹Œ?**

* ì¼ë°˜ `setInterval`ì„ ì‚¬ìš©í•˜ë©´ ì• ë‹ˆë©”ì´ì…˜ì´ ëŠê¸°ëŠ” í˜„ìƒì´ ë°œìƒí•¨.
* `requestAnimationFrame`ì€ ë¸Œë¼ìš°ì €ê°€ ìµœì í™”ëœ ë°©ì‹ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜ì„ ì²˜ë¦¬í•´ì„œ ë¶€ë“œëŸ¬ìš´ íš¨ê³¼ë¥¼ ì œê³µ!

<br/>

#### 4. handleMouseMoveë¡œ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ íšŒì „ê°’ ë³€ê²½

```tsx
const handleMouseMove = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
  const rect = e.currentTarget.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const centerX = rect.width / 2;
  const centerY = rect.height / 2;
  const deltaX = (mouseX - centerX) / centerX;
  const deltaY = (mouseY - centerY) / centerY;

  gMatrixRef.current = {
    a: 1,
    b: deltaY * 0.01675,
    c: deltaX * -0.01675,
    d: 1,
    e: deltaX * 11,
    f: deltaY * -8,
  };

  rotationRef.current = deltaX * 10;
};
```

* ë§ˆìš°ìŠ¤ê°€ ìš”ì†Œì˜ ì¤‘ì‹¬ì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì¡ŒëŠ”ì§€ ê³„ì‚°
* `deltaX`, `deltaY`ë¥¼ ì‚¬ìš©í•´ X, Y ë°©í–¥ìœ¼ë¡œ ë³€í™”ëŸ‰ ì„¤ì •
* `gMatrixRef.current`ë¥¼ ì—…ë°ì´íŠ¸í•´ì„œ SVG ìš”ì†Œë¥¼ ë³€í˜•
* `rotationRef.current`ë¥¼ ë³€ê²½í•´ ë‚˜ì¹¨ë°˜ì´ íšŒì „í•˜ë„ë¡ ì„¤ì •

ğŸ’¡ **ê²°ê³¼**

* ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì´ë©´ ë‚˜ì¹¨ë°˜ì´ ìì—°ìŠ¤ëŸ½ê²Œ ê¸°ìš¸ì–´ì§€ê³  íšŒì „í•˜ëŠ” íš¨ê³¼ê°€ ë§Œë“¤ì–´ì§!

***

## 3ï¸âƒ£ SVG ì„ ì´ ê·¸ë ¤ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ (useDashAnimation.ts)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

SVGì—ì„œ ì„ ì´ ì ì  ê·¸ë ¤ì§€ëŠ” ë“¯í•œ íš¨ê³¼ë¥¼ ì£¼ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ë‹´ë‹¹í•´ìš”.
`stroke-dasharray` ì†ì„±ì„ ì¡°ì ˆí•˜ë©´ ì„ ì´ ì ì§„ì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ëŠë‚Œì„ ì¤„ ìˆ˜ ìˆì–´ìš”.

âœ”ï¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš© ì˜ˆì‹œ

* ë‚˜ì¹¨ë°˜ ì„ ì´ ê·¸ë ¤ì§€ëŠ” íš¨ê³¼ (BigCompass.tsx, SmallCompass.tsx)
* í…ìŠ¤íŠ¸ ìœ¤ê³½ì´ ê·¸ë ¤ì§€ëŠ” íš¨ê³¼ (WordText.tsx)
* ë‹¤ì–‘í•œ SVG ì•„ì´ì½˜ì— ìì—°ìŠ¤ëŸ¬ìš´ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€

ì¦‰, SVG ìš”ì†Œê°€ ë“±ì¥í•  ë•Œ ìì—°ìŠ¤ëŸ½ê²Œ ë³´ì´ë„ë¡ í•˜ëŠ” ì—­í• ì„ í•´ìš”!
ìš°ì„  ì•„ë˜ëŠ” ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
import { UseDashAnimationProps } from "@/types/props";
import { useState, useEffect } from "react";

export function useDashAnimation({ 
  delay = 2000, 
  duration = 2000, 
  intervalTime = 20, 
  startValue = 25, 
  intervalCount = 0 
}: UseDashAnimationProps) {
	const [dashArray, setDashArray] = useState(startValue);
	const [isVisible, setIsVisible] = useState(false); // ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ ìƒíƒœ

	useEffect(() => {
		const steps = duration / intervalTime; // ì‹¤í–‰ íšŸìˆ˜ ê³„ì‚° (2000ms / 20ms = 100ë²ˆ)
		const stepSize = startValue / steps;   // í•œ ë²ˆì— ì¤„ì–´ë“œëŠ” ê°’ (25 / 100 = 0.25)

		let currentDash = startValue;
		let interval: NodeJS.Timeout;

		// delay í›„ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
		const timeout = setTimeout(() => {
			setIsVisible(true); // SVG ë³´ì´ê¸° ì‹œì‘

			interval = setInterval(() => {
				currentDash -= stepSize; // ê°’ ê°ì†Œ
				if (currentDash <= intervalCount + 1) {
					clearInterval(interval);
					setDashArray(intervalCount); // ë§ˆì§€ë§‰ ê°’ ê³ ì •
				} else {
					setDashArray(currentDash);
				}
			}, intervalTime);

		}, delay); // delay í›„ ì‹¤í–‰

		// í´ë¦°ì—… (ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬)
		return () => {
			clearTimeout(timeout);
			clearInterval(interval);
		};
	}, [delay, duration, intervalTime, startValue, intervalCount]);

	return { dashArray, isVisible };
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

#### 1. ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸° ìƒíƒœ ì„¤ì •

```tsx
const [dashArray, setDashArray] = useState(startValue);
const [isVisible, setIsVisible] = useState(false);

```

* `dashArray`: í˜„ì¬ `stroke-dasharray`ì˜ ê°’ì„ ì €ì¥í•˜ëŠ” ìƒíƒœ
* `isVisible`: SVGê°€ ë³´ì´ëŠ” ìƒíƒœë¥¼ ì¡°ì ˆ (ì´ˆê¸°ì—ëŠ” `false`ë¡œ ì„¤ì •)

ğŸ’¡ **stroke-dasharrayë€?**

* `stroke-dasharray`: 100; â†’ ì„ ì´ 100px ê¸¸ì´ë¡œ ë³´ì„
* `stroke-dasharray`: 0; â†’ ì„ ì´ ì™„ì „íˆ ìˆ¨ê²¨ì§
* `stroke-dasharray`ë¥¼ ì ì  ì¤„ì´ë©´ ì„ ì´ ê·¸ë ¤ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ì²˜ëŸ¼ ë³´ì´ê²Œ í•  ìˆ˜ ìˆìŒ! ğŸ¨

<br/>

#### 2. ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰ ì¤€ë¹„ (useEffect ë‚´ë¶€)

```tsx
const steps = duration / intervalTime; // ì‹¤í–‰ íšŸìˆ˜ ê³„ì‚°
const stepSize = startValue / steps;   // í•œ ë²ˆì— ê°ì†Œí•˜ëŠ” í¬ê¸°
```

âœ”ï¸ ì• ë‹ˆë©”ì´ì…˜ì´ ëª‡ ë²ˆ ì‹¤í–‰ë ì§€ ê³„ì‚°

* ê¸°ë³¸ê°’ìœ¼ë¡œ `duration = 2000ms`, `intervalTime = 20ms`ë¼ë©´? â†’ `2000 / 20 = 100ë²ˆ` ì‹¤í–‰ (í•œ ë²ˆ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ê°ì†Œí•˜ëŠ” í¬ê¸° ê³„ì‚°)

* ê¸°ë³¸ê°’ `startValue = 25`, `steps = 100` (í•œ ë²ˆ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ `0.25px`ì”© ê°ì†Œ)


<br/>

#### 3. setTimeout()ì„ ì‚¬ìš©í•´ ì• ë‹ˆë©”ì´ì…˜ ì§€ì—°

```tsx
const timeout = setTimeout(() => {
  setIsVisible(true); // SVGê°€ ë³´ì´ë„ë¡ ì„¤ì •
```

* ì• ë‹ˆë©”ì´ì…˜ì´ ë°”ë¡œ ì‹œì‘ë˜ì§€ ì•Šê³ , `delay` í›„ ì‹¤í–‰
* `setIsVisible(true);`ë¥¼ ì‹¤í–‰í•´ì„œ ì²˜ìŒì—ëŠ” ìˆ¨ê²¨ë†¨ë˜ SVGë¥¼ ë³´ì´ë„ë¡ ë³€ê²½

<br/>

#### 4. setInterval()ì„ ì´ìš©í•´ stroke-dasharray ë³€ê²½

```tsx
interval = setInterval(() => {
  currentDash -= stepSize; // ê°’ ê°ì†Œ
  if (currentDash <= intervalCount + 1) {
    clearInterval(interval);
    setDashArray(intervalCount); // ë§ˆì§€ë§‰ ê°’ ê³ ì •
  } else {
    setDashArray(currentDash);
  }
}, intervalTime);
```

* ì¼ì • ê°„ê²©(`intervalTime = 20ms`)ìœ¼ë¡œ `dashArray` ê°’ì„ ì ì  ì¤„ì—¬ì„œ ì„ ì„ ê·¸ë ¤ì§€ëŠ” ë“¯í•œ íš¨ê³¼
* `currentDash`ê°€ `intervalCount`ë³´ë‹¤ ì‘ì•„ì§€ë©´ ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ
* `setDashArray(currentDash);`ë¡œ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì„œ ë¦¬ë Œë”ë§ì„ ìœ ë„

<br/>

#### 5. useEffectì˜ í´ë¦°ì—… í•¨ìˆ˜

```tsx
return () => {
  clearTimeout(timeout);
  clearInterval(interval);
};
```

* ì»´í¬ë„ŒíŠ¸ê°€ ì‚¬ë¼ì§€ê±°ë‚˜ ë¦¬ë Œë”ë§ë  ë•Œ ì• ë‹ˆë©”ì´ì…˜ì„ ì¤‘ì§€
* ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê³  ì„±ëŠ¥ ìµœì í™”

***

## 4ï¸âƒ£ íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜ (useTypewriterEffect.ts)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

* âœ… í…ìŠ¤íŠ¸ë¥¼ í•œ ê¸€ìì”© ì°¨ë¡€ë¡œ ë“±ì¥ì‹œí‚¤ëŠ” íš¨ê³¼
* âœ… íŠ¹ì • ì‹œê°„ì´ ì§€ë‚˜ë©´ ë‹¤ìŒ ë¬¸êµ¬ë¡œ ì „í™˜
* âœ… ë§ˆì§€ë§‰ ë¬¸êµ¬(Scroll Down)ì€ ìœ„ì•„ë˜ë¡œ í”ë“¤ë¦¬ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
* âœ… **ë¬´í•œ ë°˜ë³µ(repeat: -1)**ì„ í†µí•´ ê³„ì† ì›€ì§ì´ë„ë¡ ì„¤ì •

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

#### 1. í•œ ê¸€ìì”© spanìœ¼ë¡œ ê°ì‹¸ê¸°

```tsx
rowRefs.current.forEach((div) => {
  const text = div.textContent || "";
  div.innerHTML = ""; // ê¸°ì¡´ í…ìŠ¤íŠ¸ ì œê±°

  text.split("").forEach((char) => {
    const span = document.createElement("span");
    span.textContent = char;
    span.style.opacity = "0"; // ì²˜ìŒì—ëŠ” ì•ˆ ë³´ì´ë„ë¡ ì„¤ì •
    div.appendChild(span);
  });
});
```

* ê¸°ì¡´ í…ìŠ¤íŠ¸ë¥¼ í•œ ê¸€ìì”© `span` íƒœê·¸ë¡œ ê°ì‹¸ì„œ ê°œë³„ ì• ë‹ˆë©”ì´ì…˜ì´ ê°€ëŠ¥í•˜ë„ë¡ ë³€í™˜
* `span.style.opacity = "0";` â†’ ì²˜ìŒì—ëŠ” ë³´ì´ì§€ ì•Šë„ë¡ ì„¤ì •

<br/>

#### 2. GSAPì„ ì´ìš©í•œ íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜
  
```tsx
const masterTimeline = gsap.timeline({ repeat: -1 });

masterTimeline.to(firstRowRefs.current.map((div) => Array.from(div.children)), {
    opacity: 1,
    duration: 0.03,
    stagger: 0.03, // í•˜ë‚˜ì”© ë“±ì¥í•˜ë„ë¡ ì„¤ì •
    delay: 4,
  })
  .to(firstRowRefs.current.map((div) => Array.from(div.children)), {
    opacity: 0,
    duration: 0.03,
    stagger: 0.03,
  }, "+=1");
```

* `stagger: 0.03` â†’ ê¸€ìë§ˆë‹¤ 0.03ì´ˆì”© ê°„ê²©ì„ ë‘ê³  ë“±ì¥
* `repeat: -1` â†’ ë¬´í•œ ë°˜ë³µ
* `delay: 4` â†’ ì²« ë²ˆì§¸ ë¬¸êµ¬ëŠ” 4ì´ˆ í›„ ì‹¤í–‰
* `.to(..., "+=1")` â†’ 1ì´ˆ í›„ ì‚¬ë¼ì§€ê³  ë‹¤ìŒ ë¬¸êµ¬ ë“±ì¥

<br/>

#### 3. "Scroll Down" ì• ë‹ˆë©”ì´ì…˜(ë³„ë„ íƒ€ì„ë¼ì¸)

```tsx
const fourthTimeLine = gsap.timeline({ repeat: -1 });

fourthTimeLine.to(fourthRowRefs.current.map((div) => Array.from(div.children)), {
    opacity: 1,
    duration: 0.05,
    stagger: 0.05,
    delay: 2,
  })
  .to(fourthRowRefs.current.map((div) => Array.from(div.children)), {
    y: -10,
    stagger: 0.05,
    scale: 1.2,
    marginRight: "0.6rem",
    repeat: 3,
    yoyo: true,
    fontWeight: "700",
  })
  .to(fourthRowRefs.current.map((div) => Array.from(div.children)), {
    y: 0,
    stagger: 0.05,
    scale: 1,
    marginRight: "0.2rem",
    fontWeight: "400",
  });
```

* `y: -10` â†’ ìœ„ì•„ë˜ë¡œ ì‚´ì§ í”ë“¤ë¦¬ëŠ” íš¨ê³¼
* `scale: 1.2` â†’ í¬ê¸°ê°€ ì»¤ì§€ëŠ” íš¨ê³¼
* `yoyo: true` â†’ ìœ„ë¡œ ê°”ë‹¤ê°€ ë‹¤ì‹œ ë‚´ë ¤ì˜¤ëŠ” ë°˜ë³µ íš¨ê³¼
* `repeat: 3` â†’ ì„¸ ë²ˆ ë°˜ë³µ

***

## 5ï¸âƒ£ useYPositions.ts â€“ ìš”ì†Œë“¤ì˜ Y ìœ„ì¹˜ë¥¼ ë™ì ìœ¼ë¡œ ê³„ì‚°í•˜ì—¬ ë°°ì¹˜

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

* âœ… íŠ¹ì • ìš”ì†Œë“¤(grid_item)ì˜ Y ìœ„ì¹˜ë¥¼ ì¶”ì 
* âœ… ìŠ¤í¬ë¡¤í•  ë•Œë§ˆë‹¤ Y ì¢Œí‘œ ì—…ë°ì´íŠ¸
* âœ… ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ê°ì§€ â†’ ì°½ í¬ê¸°ê°€ ë³€í•  ë•Œì—ë„ ë°˜ì‘
* âœ… MutationObserver ì‚¬ìš© â†’ DOM ìš”ì†Œê°€ ë³€í•  ë•Œë„ ìë™ ì—…ë°ì´íŠ¸

ìš°ì„  ì•„ë˜ëŠ” ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
'use client';

import { useEffect, useState } from 'react';

export function useYPositions(pxRefs: React.RefObject<HTMLDivElement[]>, listConfig: number[], bgElemRef: React.RefObject<HTMLDivElement | null>) {
  const [yPositions, setYPositions] = useState<number[]>([]); // Y ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” state

  useEffect(() => {
    const updateYPositions = () => {
      if (pxRefs.current.length > 0 && bgElemRef.current) {
        // bg_elem ìš”ì†Œê°€ í™”ë©´ì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ ê³„ì‚°
        const parentTop = bgElemRef.current.getBoundingClientRect().top;

        // pxRefs ë°°ì—´ì„ ìˆœíšŒí•˜ë©° ê° ìš”ì†Œì˜ Y ì¢Œí‘œ ê³„ì‚°
        const positions = pxRefs.current.map((el) =>
          el ? Math.floor(el.getBoundingClientRect().top - parentTop) : 0
        );

        // ê¸°ì¡´ ê°’ê³¼ ë¹„êµ í›„ ë³€ê²½ì´ ìˆìœ¼ë©´ ìƒíƒœ ì—…ë°ì´íŠ¸
        setYPositions((prevY) => {
          if (JSON.stringify(prevY) !== JSON.stringify(positions)) {
            return positions;
          }
          return prevY;
        });
      }
    };

    // ì´ˆê¸° Y ìœ„ì¹˜ ì„¤ì •
    updateYPositions();

    // ğŸ“Œ MutationObserver: ìš”ì†Œ ë³€ê²½ ê°ì§€
    const observer = new MutationObserver(updateYPositions);
    pxRefs.current.forEach((el) => {
      if (el) observer.observe(el, { attributes: true, subtree: true });
    });

    // ğŸ“Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (ìŠ¤í¬ë¡¤ & ë¦¬ì‚¬ì´ì¦ˆ)
    window.addEventListener("resize", updateYPositions);
    window.addEventListener("scroll", updateYPositions);

    return () => {
      // ì–¸ë§ˆìš´íŠ¸ ì‹œ ë¦¬ìŠ¤ë„ˆ & ì˜µì €ë²„ ì •ë¦¬
      window.removeEventListener("resize", updateYPositions);
      window.removeEventListener("scroll", updateYPositions);
      observer.disconnect();
    };
  }, [pxRefs, listConfig, bgElemRef]);

  return yPositions;
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

#### 1. Y ìœ„ì¹˜ë¥¼ ì¶”ì í•  ìš”ì†Œ ë¦¬ìŠ¤íŠ¸ (pxRefs)

```tsx
const [yPositions, setYPositions] = useState<number[]>([]); // Y ìœ„ì¹˜ ì €ì¥
```

* `yPositions`ëŠ” ê° ìš”ì†Œì˜ Y ì¢Œí‘œ ê°’ì„ ì €ì¥í•˜ëŠ” ìƒíƒœì…ë‹ˆë‹¤.
* ì´ˆê¸°ê°’ì€ `ë¹ˆ ë°°ì—´([])`ì´ë©°, íŠ¹ì • ì¡°ê±´ì—ì„œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.

<br/>

#### 2. updateYPositions í•¨ìˆ˜ â€“ ìš”ì†Œì˜ í˜„ì¬ Y ì¢Œí‘œ ê³„ì‚°

```tsx
const updateYPositions = () => {
  if (pxRefs.current.length > 0 && bgElemRef.current) {
    const parentTop = bgElemRef.current.getBoundingClientRect().top;

    const positions = pxRefs.current.map((el) =>
      el ? Math.floor(el.getBoundingClientRect().top - parentTop) : 0
    );

    setYPositions((prevY) => {
      if (JSON.stringify(prevY) !== JSON.stringify(positions)) {
        return positions;
      }
      return prevY;
    });
  }
};
```

* íŠ¹ì • ìš”ì†Œ(`pxRefs.current`)ë“¤ì˜ í˜„ì¬ Y ì¢Œí‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
* ê¸°ì¤€ì´ ë˜ëŠ” ë¶€ëª¨ ìš”ì†Œ(`bgElemRef.current`)ì˜ Y ì¢Œí‘œë¥¼ ëº€ ê°’ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.
* ì´ì „ ê°’ê³¼ ë¹„êµí•˜ì—¬ ë³€ê²½ì´ ìˆìœ¼ë©´ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

<br/>

#### 3. MutationObserverë¥¼ í™œìš©í•œ ìš”ì†Œ ë³€ê²½ ê°ì§€

```tsx
const observer = new MutationObserver(updateYPositions);
pxRefs.current.forEach((el) => {
  if (el) observer.observe(el, { attributes: true, subtree: true });
});
```

* MutationObserverë¥¼ ì‚¬ìš©í•˜ì—¬ ìš”ì†Œ(grid_item)ê°€ ë³€ê²½ë  ë•Œ updateYPositionsì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
* attributes: true, subtree: true â†’ ì†ì„± ë³€ê²½ & ë‚´ë¶€ ìš”ì†Œ ë³€ê²½ ê°ì§€

<br/>

#### 4. ìŠ¤í¬ë¡¤ & ë¦¬ì‚¬ì´ì¦ˆ ê°ì§€í•˜ì—¬ Y ì¢Œí‘œ ì—…ë°ì´íŠ¸

```tsx
window.addEventListener("resize", updateYPositions);
window.addEventListener("scroll", updateYPositions);
```

* ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ updateYPositionsì„ ì‹¤í–‰í•˜ì—¬ ìš”ì†Œì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ ë°˜ì˜
* ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ë©´ í™”ë©´ í¬ê¸°ì— ë”°ë¼ ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ ê³„ì‚°

<br/>

#### 5. ì •ë¦¬ (Cleanup)

```tsx
return () => {
  window.removeEventListener("resize", updateYPositions);
  window.removeEventListener("scroll", updateYPositions);
  observer.disconnect();
};
```

* ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë  ë•Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì™€ `MutationObserver`ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
* ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ í•„ìˆ˜ ì‘ì—…!

***

## 6ï¸âƒ£ ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ (Grid.tsx)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

* âœ… Grid.tsx (ë©”ì¸ ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ)
* âœ… GridColumn.tsx (ê° ì»¬ëŸ¼ì„ ê´€ë¦¬í•˜ëŠ” ì„œë¸Œ ì»´í¬ë„ŒíŠ¸)
* âœ… useYPositions.ts í›…ê³¼ ì—°ê²°í•˜ì—¬ ìš”ì†Œ ìœ„ì¹˜ ì¶”ì 
* âœ… ê·¸ë¦¬ë“œ ì•„ì´í…œì„ ë™ì ìœ¼ë¡œ ìƒì„±í•˜ê³  ë°°ì¹˜
* âœ… Refë¥¼ í™œìš©í•˜ì—¬ ìš”ì†Œì˜ ìœ„ì¹˜ë¥¼ ê¸°ì–µ & ì—…ë°ì´íŠ¸

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„

#### 1. ë©”ì¸ Grid ì»´í¬ë„ŒíŠ¸

```tsx
'use client';

import { useRegisterHTMLRef } from "@/hooks/useArrayRef";
import { useYPositions } from "@/hooks/useYPositions";
import { GridProps, GridColumnProps } from "@/types/props";
import React, { useRef } from 'react';

// ğŸ“Œ ë©”ì¸ BgGrid ì»´í¬ë„ŒíŠ¸ START!
export default function Grid({ gridColumns }: GridProps) {
  if (!gridColumns || !Array.isArray(gridColumns)) { // gridColumnsì´ ì—†ê±°ë‚˜ ë°°ì—´ì´ ì•„ë‹ˆë¼ë©´
    console.error("BgGrid", gridColumns); // ì˜¤ë¥˜ ë©”ì‹œì§€ ì¶œë ¥
    return null; // ê·¸ë¦¬ê³  null ë°˜í™˜(ì•ˆì „í•œ ë Œë”ë§ì„ ìœ„í•¨)
  }

  return (
    <div className="grid">
      {gridColumns.map((col, colIndex) => (
        <GridColumn key={colIndex} gap={col.gap} paddingTop={col.paddingTop} listConfig={col.listConfig} gridListRefs={col.gridListRefs} scrollStartRef={col.scrollStartRef}/>
      ))}
    </div>
  );
}
// ğŸ“Œ ë©”ì¸ BgGrid ì»´í¬ë„ŒíŠ¸ END!
```

* `Grid`ëŠ” ê·¸ë¦¬ë“œ ì»¬ëŸ¼ì„ ê°ì‹¸ëŠ” ë©”ì¸ ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤.
* ì´ ì»´í¬ë„ŒíŠ¸ëŠ” `gridColumns` ë°°ì—´ì„ ë°›ì•„ì„œ ê° `GridColumn`ì„ ìƒì„±í•©ë‹ˆë‹¤.
* ë°°ì—´ì´ `null`ì´ê±°ë‚˜ ì˜ëª»ëœ ê°’ì´ ë“¤ì–´ì˜¤ë©´ `console.error`ë¥¼ ì°ê³  ë Œë”ë§ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.

<br/>

#### 2. ê·¸ë¦¬ë“œ ì»¬ëŸ¼ì„ ë™ì ìœ¼ë¡œ ìƒì„±

```tsx
{gridColumns.map((col, colIndex) => (
  <GridColumn key={colIndex} 
    gap={col.gap} 
    paddingTop={col.paddingTop} 
    listConfig={col.listConfig} 
    gridListRefs={col.gridListRefs} 
    scrollStartRef={col.scrollStartRef}
  />
))}
```

* `gridColumns`ì— ë‹´ê¸´ ë°ì´í„°ë¥¼ `map()`ì„ ì´ìš©í•´ í•˜ë‚˜ì”©`GridColumn` ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬
* ê° `GridColumn`ì˜ ê°„ê²©, íŒ¨ë”©, ë¦¬ìŠ¤íŠ¸ ì„¤ì •ì„ ë°›ì•„ì„œ ê°œë³„ ìŠ¤íƒ€ì¼ì„ ì ìš©

<br/>

#### 3. GridColumn.tsx â€“ ê°œë³„ ì»¬ëŸ¼ì„ ë‹´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸

```tsx
// ğŸ“Œ ê°œë³„ `GridColumn` ì»´í¬ë„ŒíŠ¸ START!
const GridColumn: React.FC<GridColumnProps> = ({ gap, paddingTop, listConfig, gridListRefs, scrollStartRef }) => {
  const pxRefs = useRef<HTMLDivElement[]>([]); // grid_item ìš”ì†Œì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
  const yPositions = useYPositions(pxRefs, listConfig, scrollStartRef);

  const setGridItemRef = useRegisterHTMLRef(gridListRefs);
  const setGridPxRef = useRegisterHTMLRef(pxRefs);

  return (
    <div className="grid_col" style={{ gap, paddingTop }}>

      {listConfig.map((itemCount, listIndex) => (
        <div ref={setGridItemRef} className="grid_list" key={listIndex}>

          {Array.from({ length: itemCount }, (_, itemIndex) => { // ê¸¸ì´ê°€ itemCountì¸ ë°°ì—´ì„ ìƒì„±
            const itemPosIndex = listConfig.slice(0, listIndex)
              .reduce((acc, val) => acc + val, 0) + itemIndex;

            return (
              <div className="grid_item" key={`${listIndex}-${itemIndex}`}>
                <div ref={setGridPxRef} className="grid_px">
                  {`${yPositions[itemPosIndex]}px` || `XXX`}
                </div>
              </div>
            );
          })}
        </div>
      ))}

    </div>
  );
};
// ğŸ“Œ ê°œë³„ `GridColumn` ì»´í¬ë„ŒíŠ¸ END!
```

*  `GridColumn`ì€ ê°œë³„ ê·¸ë¦¬ë“œ ì»¬ëŸ¼ì„ ë Œë”ë§í•˜ëŠ” ì—­í• 
*  `gap`, `paddingTop` ë“±ì˜ ê°’ì„ ë°›ì•„ ê° ì»¬ëŸ¼ì˜ ì—¬ë°±ê³¼ ìŠ¤íƒ€ì¼ì„ ì¡°ì •
*  `listConfig`ë¥¼ í†µí•´ ê° ì»¬ëŸ¼ì— í¬í•¨ë  ì•„ì´í…œ ê°œìˆ˜ë¥¼ ê²°ì •
*  `useYPositions` í›…ì„ ì´ìš©í•´ ê° ì•„ì´í…œì˜ ìœ„ì¹˜ë¥¼ ì¶”ì 

***


#### 4. pxRefsë¡œ grid_item ìš”ì†Œ ìœ„ì¹˜ ì €ì¥


```tsx
const pxRefs = useRef<HTMLDivElement[]>([]); // grid_item ìš”ì†Œì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
const yPositions = useYPositions(pxRefs, listConfig, scrollStartRef);
```

*  `pxRefs` â†’ `grid_item`ë“¤ì˜ ì°¸ì¡°ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
*  `useYPositions` í›…ì„ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ì•„ì´í…œì˜ ìœ„ì¹˜ë¥¼ ì¶”ì 

<br/>

#### 5. listConfigë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë™ì  ì•„ì´í…œ ìƒì„±

```tsx
{listConfig.map((itemCount, listIndex) => (
  <div ref={setGridItemRef} className="grid_list" key={listIndex}>

    {Array.from({ length: itemCount }, (_, itemIndex) => { 
      const itemPosIndex = listConfig.slice(0, listIndex)
        .reduce((acc, val) => acc + val, 0) + itemIndex;

      return (
        <div className="grid_item" key={`${listIndex}-${itemIndex}`}>
          <div ref={setGridPxRef} className="grid_px">
            {`${yPositions[itemPosIndex]}px` || `XXX`}
          </div>
        </div>
      );
    })}
  </div>
))}
```

* `listConfig` â†’ ëª‡ ê°œì˜ `grid_item`ì„ ìƒì„±í• ì§€ë¥¼ ê²°ì •
* `Array.from()`ì„ ì‚¬ìš©í•˜ì—¬ `grid_item`ì„ ë™ì ìœ¼ë¡œ ìƒì„±
* ê° `grid_item`ì— Y ì¢Œí‘œ `yPositions[itemPosIndex]`ë¥¼ ì¶œë ¥

***

## 7ï¸âƒ£ ì›€ì§ì´ëŠ” ë‚˜ì¹¨ë°˜ íš¨ê³¼ (BigCompass.tsx & SmallCompass.tsx)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥(BigCompass.tsx)

* âœ… `BigCompass.tsx` â€“ í° ë‚˜ì¹¨ë°˜ì„ ìƒì„±í•˜ê³  ë¶€ë“œëŸ½ê²Œ íšŒì „
* âœ… `useDashAnimation.ts` í›…ì„ ì‚¬ìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ ì¶”ê°€

`BigCompass.tsx`ì˜ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
'use client';

import { useDashAnimation } from "@/hooks/useDashAnimation";
import { Matrix } from "@/types/props";

export default function BigCompass({ gMatrix, circleMatrix }: { gMatrix: Matrix, circleMatrix: Matrix }) {
	const { dashArray, isVisible } = useDashAnimation({ delay: 2000, duration: 2000, intervalTime: 10, startValue: 100, intervalCount: 20 });

	return (
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1441.21 1441.21" 
			style={{ visibility: isVisible ? "visible" : "hidden", strokeDasharray: `1px, ${dashArray}px`}}>
			
			{/* Xì ì¶•ì„  (ì‹­ì ëª¨ì–‘ ì„ ) */}
			<g strokeWidth="1" transform={`matrix(${gMatrix.a},${gMatrix.b},${gMatrix.c},${gMatrix.d},${gMatrix.e},${gMatrix.f})`}>
				<line x1="720.85" y1="720.85" x2="720.85" y2=".35" stroke="var(--thema)" strokeWidth={5} vectorEffect="non-scaling-stroke"/>
				<line x1="720.85" y1="720.85" x2="720.85" y2="1440.85" stroke="var(--thema)" strokeWidth={5} vectorEffect="non-scaling-stroke"/>
				<line x1="720.85" y1="720.85" x2=".35" y2="720.85" stroke="var(--thema)" strokeWidth={5} vectorEffect="non-scaling-stroke"/>
				<line x1="720.85" y1="720.85" x2="1440.85" y2="720.85" stroke="var(--thema)" strokeWidth={5} vectorEffect="non-scaling-stroke"/>
			</g>

			{/* ì›í˜• ë‚˜ì¹¨ë°˜ */}
			<circle cx="720.35" cy="720.35" r="420" stroke="var(--thema)" strokeWidth={5} fill="none" vectorEffect="non-scaling-stroke" 
				transform={`matrix(${circleMatrix.a},${circleMatrix.b},${circleMatrix.c},${circleMatrix.d},${circleMatrix.e},${circleMatrix.f})`}/>
		</svg>
	)
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„(BigCompass.tsx)

* `BigCompass.tsx`ëŠ” ì¤‘ì•™ì—ì„œ íšŒì „í•˜ëŠ” ì»¤ë‹¤ë€ ë‚˜ì¹¨ë°˜
* SVG ìš”ì†Œë¥¼ í™œìš©í•´ ë‚˜ì¹¨ë°˜ì„ êµ¬ì„±
* ì‹­ì ëª¨ì–‘ ì¶•ì„  + ì›í˜• ë‚˜ì¹¨ë°˜
* `useDashAnimation.ts`ë¥¼ í™œìš©í•´ ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
* `gMatrix & circleMatrix`ë¥¼ ë°›ì•„ì„œ ë™ì ìœ¼ë¡œ ë³€í˜•

#### âœ… useDashAnimation.tsë¥¼ í™œìš©í•œ ì„  ì• ë‹ˆë©”ì´ì…˜

```tsx
const { dashArray, isVisible } = useDashAnimation({ delay: 2000, duration: 2000, intervalTime: 10, startValue: 100, intervalCount: 20 });
```

* `ashArray` â†’ SVG ì„ ì˜ ê¸¸ì´ë¥¼ ì¡°ì ˆí•˜ì—¬ ë‚˜íƒ€ë‚˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ êµ¬í˜„
* `isVisible` â†’ ì• ë‹ˆë©”ì´ì…˜ì´ ì‹œì‘ë  ë•Œê¹Œì§€ ìˆ¨ê¹€ ì²˜ë¦¬
* `delay`, `duration`, `intervalTime`ì„ í™œìš©í•´ ì• ë‹ˆë©”ì´ì…˜ ì¡°ì ˆ

***

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥(SmallCompass.tsx)

* âœ… `BigCompass.tsx` â€“ í° ë‚˜ì¹¨ë°˜ì„ ìƒì„±í•˜ê³  ë¶€ë“œëŸ½ê²Œ íšŒì „
* âœ… `useDashAnimation.ts` í›…ì„ ì‚¬ìš©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ ì¶”ê°€

`SmallCompass.tsx`ì˜ ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
'use client';
import { useDashAnimation } from "@/hooks/useDashAnimation";

export default function SmallCompass({rotation}: { rotation: number}) {
	const { dashArray, isVisible } = useDashAnimation({ delay: 4000, duration: 1500, intervalTime: 10, startValue: 25, intervalCount: 3 });

	return (
		<svg width="50" height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg" 
			style={{ visibility: isVisible ? "visible" : "hidden", transform: `rotate(${rotation}deg)`, strokeDasharray: `1px, ${dashArray}px` }}>
			
			{/* ë‚˜ì¹¨ë°˜ì˜ ê¸°ë³¸ ì¶• */}
			<line x1="24.5" y1="24.5" x2="24.5" y2="0" stroke="var(--thema)" strokeWidth={3} vectorEffect="non-scaling-stroke"/>
			<line x1="24.5" y1="24.5" x2="35.5" y2="13.5" stroke="var(--thema)" strokeWidth={3} vectorEffect="non-scaling-stroke"/>
			<line x1="24.5" y1="24.5" x2="50" y2="24.5" stroke="var(--thema)" strokeWidth={3} vectorEffect="non-scaling-stroke"/>
			<line x1="24.5" y1="24.5" y2="24.5" stroke="var(--thema)" strokeWidth={3} vectorEffect="non-scaling-stroke"/>
			<line x1="24.5" y1="24.5" x2="24.5" y2="50" stroke="var(--thema)" strokeWidth={3} vectorEffect="non-scaling-stroke"/>
		</svg>
	)
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„(SmallCompass.tsx)

* `SmallCompass.tsx`ëŠ” ëœë¤í•œ íšŒì „ê°ì„ ê°€ì§€ëŠ” ì‘ì€ ë‚˜ì¹¨ë°˜
* SVG ìš”ì†Œë¡œ ë‚˜ì¹¨ë°˜ì„ êµ¬ì„±
* ëœë¤í•œ `rotation` ê°’ì„ ë°›ì•„ íšŒì „
* ì‘ì€ í¬ê¸°ì˜ ë‚˜ì¹¨ë°˜ì´ ë¶€ë“œëŸ½ê²Œ ë‚˜íƒ€ë‚˜ë„ë¡ ì„¤ì •

***

## 8ï¸âƒ£ ë¶€ë“œëŸ¬ìš´ ì›¨ì´ë¸Œ ì• ë‹ˆë©”ì´ì…˜ (Wave.tsx)

### ğŸ¦„ í•µì‹¬ ê¸°ëŠ¥

* âœ… SVGë¥¼ ì‚¬ìš©í•´ ë¶€ë“œëŸ¬ìš´ ë¬¼ê²° ì• ë‹ˆë©”ì´ì…˜ì„ ìƒì„±
* âœ… ë‹¤ì¸µ ë ˆì´ì–´ (3ë‹¨ê³„ ì›¨ì´ë¸Œ)ë¡œ ê¹Šì´ê°ì„ í‘œí˜„
* âœ… `useRef`ë¥¼ ì´ìš©í•´ì„œ íŠ¹ì • ìš”ì†Œë“¤ì„ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
* âœ… `parallax` íš¨ê³¼ë¥¼ í™œìš©í•´ ìì—°ìŠ¤ëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ ì ìš©

ìš°ì„  ì•„ë˜ëŠ” ì „ì²´ ì½”ë“œì…ë‹ˆë‹¤.

```tsx
import React, { RefObject } from 'react'

export default function Wave({waveRef, waveHeightRef, waveLineBlockRef}: { 
	waveRef: RefObject<(HTMLDivElement | null)>; 
	waveHeightRef: RefObject<(HTMLDivElement | null)>;  
	waveLineBlockRef: RefObject<(HTMLDivElement | null)>; 
}) {
	return (
		<>
			{/* íŒŒë„ ì• ë‹ˆë©”ì´ì…˜ */}
			<div className="wave" ref={waveRef}>
				<svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none">
					<defs>
						{/* ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì˜ wave íŒ¨ìŠ¤ ì •ì˜ */}
						<path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
					</defs>

					{/* 3ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ íŒŒë„ì¸µì„ ì¶”ê°€í•˜ì—¬ ê¹Šì´ê°ì„ ì¤Œ */}
					<g className="parallax">
						<use xlinkHref="#gentle-wave" x="50" y="0" fill="var(--thema)"></use>
						<use xlinkHref="#gentle-wave" x="50" y="4" fill="#07aa77d1"></use>
						<use xlinkHref="#gentle-wave" x="50" y="8" fill="#07aa77a3"></use>
					</g>
				</svg>
			</div>

			{/* íŒŒë„ì˜ ë†’ì´ë¥¼ ì¡°ì ˆí•˜ëŠ” ìš”ì†Œ */}
			<div className="height" ref={waveHeightRef}></div>

			{/* íŒŒë„ì™€ í•¨ê»˜ ì›€ì§ì´ëŠ” ì„  */}
			<div className="line_block" ref={waveLineBlockRef}></div>
		</>
	)
}
```

***

### ğŸ¦„ ì½”ë“œ ë¶„ì„(SmallCompass.tsx)

```tsx
<>
	<div className="wave" ref={waveRef}></div>
	<div className="height" ref={waveHeightRef}></div>
	<div className="line_block" ref={waveLineBlockRef}></div>
</>
```

* `waveRef`, `waveHeightRef`, `waveLineBlockRef`ë¥¼ `useRef`ë¡œ ê´€ë¦¬
* ì´í›„ ìŠ¤í¬ë¡¤, ì• ë‹ˆë©”ì´ì…˜ ë™ì‘ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥

í•´ë‹¹ `ref`ë“¤ì„ `useEffect`ë¡œ ê°ì§€í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ ì¶”ê°€í•  ìˆ˜ë„ ìˆìŒ!

***

## ğŸ‰ ë§ˆë¬´ë¦¬ ë° ì •ë¦¬

ì§€ê¸ˆê¹Œì§€ ë©”ì¸ í˜ì´ì§€ë¥¼ êµ¬ì„±í•˜ëŠ” ë‹¤ì–‘í•œ ì»´í¬ë„ŒíŠ¸ì™€ í›…ì„ ê°„ëµí•˜ê²Œ ë¶„ì„í•´ ë³´ì•˜ìŠµë‹ˆë‹¤. ë©”ì¸ í˜ì´ì§€ëŠ” í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ì˜ ì²«ì¸ìƒì„ ê²°ì •í•˜ëŠ” ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ì¸ ë§Œí¼ ì‹ ê²½ì„ ë§ì´ ì¼ëŠ”ë° ìƒê°ë§Œí¼ì˜ ë§Œì¡±ìŠ¤ëŸ¬ìš´ ê²°ê³¼ë¬¼ì´ ë‚˜ì˜¨ ê²ƒ ê°™ìŠµë‹ˆë‹¤.âœ¨

ì•ìœ¼ë¡œë„ ë” ë§ì€ ì• ë‹ˆë©”ì´ì…˜ê³¼ ì¸í„°ë™ì…˜ì„ ì‹œë„í•´ ë³´ë©´ì„œ, ë”ìš± ì™„ì„±ë„ ë†’ì€ í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ë¥¼ ë§Œë“¤ì–´ ë‚˜ê°ˆ ì˜ˆì •ì…ë‹ˆë‹¤.

<img src="/images/front_study/25/image1.webp"/>