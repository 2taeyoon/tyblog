## 🦮 NextAuth와 MongoDB 연결하기

Next.js 13에서 구글 로그인 구현하고 싶다구요? `next-auth`만 있으면 로그인부터 DB 저장, 세션 관리까지 전부 다 됩니다.  
게다가 **MongoDBAdapter 없이**? 커스텀해서 사용할 수 있습니다!

---

## 🤔 왜 MongoDBAdapter 안 썼냐고요?

> MongoDBAdapter는 좋긴 한데 **제 프로젝트에 필요한 데이터 구조가 독특**했어요.

- 게임 데이터 구조 (`gameData.level`, `kodleGameWins` 등) 초기값 설정이 필요했음.
- 사용자 생성 시 커스텀 필드를 직접 제어하고 싶었음.
- `MongoDBAdapter` 쓰면 자동으로 `_id`, `emailVerified`, `email` 같은 필드만 들어가고 커스텀 데이터 삽입이 불편했음.

그래서 어댑터 대신 **직접 MongoDB에 사용자 데이터를 저장하는 방식**을 택했어요.  
이러면 내가 원하는 구조로 DB에 넣을 수 있고, 확장도 자유롭기 때문이죠 ㅎㅎㅎ..? 맞나?

---

## 🦮 프로젝트 구조 개요

| 파일 | 역할 |
|------|------|
| `src/app/api/auth/[...nextauth]/route.ts` | 로그인 인증 로직 다 들어있는 핵심 파일 |
| `src/lib/mongodb.ts` | MongoDB 연결 클라이언트 |
| `src/app/auth/Auth.tsx` | 로그인 UI 페이지 컴포넌트 |
| `.env.local` | 구글 OAuth 정보 저장 |

---

## 🦮 1. 인증 로직의 심장

`route.ts` 파일
```tsx
import NextAuth from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import clientPromise from '@/lib/mongodb';
```

여기선 `NextAuth`라는 함수를 가져와서 구글 로그인 프로바이더로 설정해요.

```ts
const handler = NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID || "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || "",
    }),
  ],
```

- 구글 로그인 프로바이더를 등록합니다.
- `clientId`, `clientSecret`은 구글 OAuth 콘솔에서 받아야 해요.

---

### 🦄 세션 전략: 왜 `jwt`?

```ts
session: { strategy: "jwt" },
```

- 기본 세션은 DB를 이용하지만, 우리는 **DB 없이도 세션을 유지할 수 있는 JWT 방식**을 사용합니다.
- 클라이언트와 서버 간 인증 상태를 간편하게 유지가 가능하기 때문이죠.

---

### 🦄 로그인 성공 시 사용자 정보 저장

```ts
async signIn({ user }) {
  // DB 연결
  const client = await clientPromise;
  const db = client.db('gemo');
  const users = db.collection('users');
```

- 로그인을 시도한 사용자가 DB에 이미 있으면? 👉 기존 사용자로 로그인
- 없으면? 👉 `gameData` 포함해서 새로 만들어줍니다

```ts
const newUser = {
  name: user.name,
  email: user.email,
  image: user.image,
  gameData: {
    level: 1,
    currentXp: 0,
    totalScore: 0,
    kodleGameWins: 0,
    kodleGameDefeat: 0,
    kodleSuccessiveVictory: 0,
    kodleMaximumSuccessiveVictory: 0,
    achievements: [],
    lastPlayed: null,
    lastAttendance: null,
    consecutiveAttendance: 0,
  },
  thema: 'light',
  notifications: true,
};
```

> 이렇게 구조화해서 사용자 데이터를 커스터마이징해서 저장합니다.

---

### 🦄 콜백 설명: jwt & session

```ts
callbacks: {
  async jwt({ token, user }) {
    if (user) token.userId = user.id;
    return token;
  },
  async session({ session, token }) {
    if (token?.userId && session.user) {
      (session.user as any).id = token.userId;
    }
    return session;
  },
}
```

- 로그인 후 토큰에 `userId`를 넣고
- 이후 `getServerSession()` 같은 곳에서 쉽게 꺼내쓸 수 있도록 `session.user.id`에 설정해줘요.

---

## 🦮 2. 로그인 버튼 UI

`Auth.tsx` 파일
```tsx
"use client";

import { signIn, getProviders } from "next-auth/react";
```

- 클라이언트 컴포넌트로, 실제 로그인 버튼을 그려줍니다.

```tsx
const [providers, setProviders] = useState(null);
useEffect(() => {
  getProviders().then(setProviders);
}, []);
```

- `getProviders()`로 로그인 방식(구글 등)을 받아옵니다.

```tsx
<button onClick={() => signIn(provider.id)}>
  {provider.name}로 로그인
</button>
```

- 버튼 클릭하면 `signIn()` 호출 → 구글 로그인 시작!

---

## 🦮 3. MongoDB 연결

`mongodb.ts` 파일
```ts
import { MongoClient } from "mongodb";

const uri = process.env.MONGODB_URI!;
const client = new MongoClient(uri);
let clientPromise = client.connect();

export default clientPromise;
```

매 요청마다 새 연결을 만들면 비효율적이니까  
`clientPromise`로 전역 연결을 재활용해요!

---

## 🦮 4. API에서 세션 확인하는 방법

```ts
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

const session = await getServerSession(authOptions);

if (!session?.user) {
  return Response.json({ error: '로그인 해주세요' }, { status: 401 });
}

const userId = session.user.id;
```

- `authOptions`를 공유해서 API에서도 로그인된 유저 식별이 가능!

---

## 🦮 요약 및 마무리

| 항목 | 설명 |
|------|------|
| MongoDBAdapter 미사용 | 사용자 구조 커스터마이징 필요해서 |
| 세션 전략 | JWT로 설정해서 서버에 부담 X |
| 사용자 저장 | 직접 MongoDB 연결해서 `users` 컬렉션에 삽입 |
| UI 구성 | `getProviders()`로 OAuth 목록 받아서 버튼 렌더링 |
| 사용자 식별 | `session.user.id`로 API에서 쉽게 추출 가능 |

구글 로그인을 구현할 때, 왜 `MongoDBAdapter`를 굳이 안 써도 되고
`NextAuth` 콜백과 `MongoDB` 클라이언트를 잘 조합하면 **완전 커스터마이징된 인증 시스템**을 구축할 수 있어요.